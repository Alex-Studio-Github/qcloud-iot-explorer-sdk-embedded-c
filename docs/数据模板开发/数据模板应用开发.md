##  数据模板业务逻辑开发
V3.2.0及以后的版本对数据模板做了较大的修改以支持多设备复用同一产品的数据模板，[自动代码生成的模板代码](https://github.com/tencentyun/qcloud-iot-explorer-sdk-embedded-c/blob/master/docs/%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90.md)基于用户传入的产品模板的json文件，自动生成了数据模板"类"，将数据模板的数据（属性、事件、行为）及对应的方法（属性值设置、属性状态获取及修改、事件参数获取、行为参数获取等）封装在数据模板中。

- 属性
  属性即对设备能力的描述，譬如智能灯，通过 `开关`、`颜色`、`亮度`三个属性实现对智能灯的能力描述，通过对属性的修改即可实现对设备的控制。

- 事件
 设备发生特定情况，譬如灯的开关状态发生了变化，上报事件。应用侧收到事件后按预设逻辑推送事件。
 
- 行为
  控制设备执行特定的行为，并将执行的结果返回。行为与属性的区别，概念上行为是数据和方法的组合，行为有执行结果的返回。属性只有数据，修改属性后设备侧是否执行成功很难在属性本身体现。

数据模板示例data_template_sample.c已实现属性、事件、动作的通用处理框架。可以基于此示例开发业务逻辑，上下行业务逻辑添加的入口函数分别为 deal_up_stream_user_logic 、deal_down_stream_user_logic。可以参考智能灯的场景示例 light_data_template_sample.c 添加业务处理逻辑。

### 初始化
- 调用`IOT_Template_Construct`构建数据模板client。
- 调用`init_data_template`创建数据模板。
- 调用`IOT_Template_Set_DataTemplate`将数据模板赋值给数据模板client
即每一个数据模板client有自己的数据模板，通过数据模板的方法可以实现对模板数据(属性、事件、行为)的操作。

### 下行业务逻辑实现

- 调用`IOT_Template_Get_DataTemplate`获取数据模板client的数据模板，通过数据模板提供的方法获取属性、事件及行为的参数，服务端下行的数据，SDK已按数据模板协议完成了数据的解析，并更新了各参数。
```
   /*获取数据模板client的数据模板
    DataTemplate *     pTemplateData = IOT_Template_Get_DataTemplate(pClient);		
		
	/*获取数据模板的属性参数
    ProductDataDefine *light         = pTemplateData->method.get_product_para(pClient);
		
	/*获取数据模板的事件参数
    EventsPara *pEventPara = pTemplateData->method.get_event_para(pClient);
		
	/*获取数据模板的行为参数
    ActionsPara * pActionPara   = pTemplateData->method.get_action_para(pClient);
```

- 用户在下行逻辑处理函数`deal_down_stream_user_logic`里使用数据模板的方法及数据添加业务逻辑。

```
/*添加用户的业务逻辑*/
void deal_down_stream_user_logic(void *pClient)
{
    Log_d("someting about your own product logic wait to be done");

#ifdef EVENT_POST_ENABLED
// IOT_Event_setFlag(pClient, EVENT_FLAG(eEVENT_STATUS_REPORT)); //set the events flag when the evnts your defined occured
#endif
}
```

- 示例用法:

```
/*智能灯数据模板属性*/
typedef struct _ProductDataDefine {
    TYPE_DEF_TEMPLATE_BOOL m_light_switch; 
    TYPE_DEF_TEMPLATE_ENUM m_color;
    TYPE_DEF_TEMPLATE_INT  m_brightness;
    TYPE_DEF_TEMPLATE_STRING m_name[MAX_STR_NAME_LEN+1];
} ProductDataDefine; 

/*智能灯数据模板事件*/
typedef struct _EventsPara {  // m_##event_name##para_name;
    TYPE_DEF_TEMPLATE_BOOL   m_status_report_status;
    TYPE_DEF_TEMPLATE_STRING m_status_report_message[64 + 1];
    TYPE_DEF_TEMPLATE_FLOAT  m_low_voltage_voltage;
    TYPE_DEF_TEMPLATE_STRING m_hardware_fault_name[64 + 1];
    TYPE_DEF_TEMPLATE_INT    m_hardware_fault_error_code;
    DeviceProperty evt_para[EVENT_STATUS_REPORT_PARA_NUM + EVENT_LOW_VOLTAGE_PARA_NUM + EVENT_HARDWARE_FAULT_PARA_NUM];
} EventsPara;

/*示例灯光控制处理逻辑*/
static void deal_down_stream_user_logic(void *pClient)
{
    int         i;
    const char *ansi_color         = NULL;
    const char *ansi_color_name    = NULL;
    char        brightness_bar[]   = "||||||||||||||||||||";
    int         brightness_bar_len = strlen(brightness_bar);

    DataTemplate *     pTemplateData = IOT_Template_Get_DataTemplate(pClient);
    ProductDataDefine *light         = pTemplateData->method.get_product_para(pClient);

    /* light color */
    switch (light->m_color) {
        case eCOLOR_RED:
            ansi_color      = ANSI_COLOR_RED;
            ansi_color_name = " RED ";
            break;
        case eCOLOR_GREEN:
            ansi_color      = ANSI_COLOR_GREEN;
            ansi_color_name = "GREEN";
            break;
        case eCOLOR_BLUE:
            ansi_color      = ANSI_COLOR_BLUE;
            ansi_color_name = " BLUE";
            break;
        default:
            ansi_color      = ANSI_COLOR_YELLOW;
            ansi_color_name = "UNKNOWN";
            break;
    }
    /* light brightness bar */
    brightness_bar_len =
        (light->m_brightness >= 100) ? brightness_bar_len : (int)((light->m_brightness * brightness_bar_len) / 100);
    for (i = brightness_bar_len; i < strlen(brightness_bar); i++) {
        brightness_bar[i] = '-';
    }

    /*handle power_switch*/
    if (light->m_power_switch) {
        /* light is on , show with the properties*/
        HAL_Printf("%s[  lighting  ]|[color:%s]|[brightness:%s]|[%s]\n" ANSI_COLOR_RESET, ansi_color, ansi_color_name,
                   brightness_bar, light->m_name);
    } else {
        /* light is off */
        HAL_Printf(ANSI_COLOR_YELLOW "[  light is off ]|[color:%s]|[brightness:%s]|[%s]\n" ANSI_COLOR_RESET,
                   ansi_color_name, brightness_bar, light->m_name);
    }

    if (eCHANGED == pTemplateData->method.get_property_state(pClient, ePROPERTY_POWER_SWITCH)) {
#ifdef EVENT_POST_ENABLED
        EventsPara *pEventPara = pTemplateData->method.get_event_para(pClient);
        if (light->m_power_switch) {
            pEventPara->m_status_report_status = TEMPLATE_TRUE;
            memset(pEventPara->m_status_report_message, 0, 64);
            strcpy(pEventPara->m_status_report_message, "light on");
        } else {
            pEventPara->m_status_report_status = TEMPLATE_FALSE;
            memset(pEventPara->m_status_report_message, 0, 64);
            strcpy(pEventPara->m_status_report_message, "light off");
        }

        // the events will be posted by eventPostCheck
        Log_d("post event EVENT_STATUS_REPORT");
        IOT_Event_setFlag(pClient, EVENT_FLAG(eEVENT_STATUS_REPORT));
#else
        Log_d("light switch state changed");
#endif
    }
}

```


###  上行业务逻辑实现
- SDK提供了属性、事件、行为的上行接口，用户可以按数据模板协议自行构造数据，然后调用接口上报相应数据。
 - 属性上报接口`IOT_Template_Report`
 - 事件上报接口`IOT_Post_Event`
 - 行为回复接口`IOT_ACTION_REPLY`

- 数据模板示例data_template_sample.c已提供了属性、事件、行为数据构造和上报的框架。
 - 对于属性上报，修改对应的属性参数，调用数据模板的属性状态设置的方法`set_property_state`将属性置为已变化`eCHANGED`，用户在`deal_up_stream_user_logic`上行处理逻辑中，调用`find_wait_report_property`汇总需要上报的属性列表，框架会调用`IOT_Template_JSON_ConstructReportArray`根据属性列表构建上报数据并调用`IOT_Template_Report`实现属性上报。
 - 对于事件，在事件产生的地方，调用`IOT_Event_setFlag`置位相应事件，框架会调用`eventPostCheck`将置位的事件自动上报。
 - 对于行为，在注册的行为回调`OnActionCallback`中，添加业务逻辑执行对应的行为，根据行为执行结果，修改给行为的输出参数，调用`IOT_ACTION_REPLY`回复行为执行结果。

 ```
// 对于属性上报，修改对应的属性参数，调用数据模板的属性状态设置的方法`set_property_state`将属性置为已变化
int deal_up_stream_user_logic(void *pClient, DeviceProperty *pReportDataList[], int *pCount)
{
    DataTemplate *pTemplateData = IOT_Template_Get_DataTemplate(pClient);

    /*find propery need report*/
    *pCount = pTemplateData->method.find_wait_report_property(pClient, pReportDataList);

    return (*pCount > 0) ? QCLOUD_RET_SUCCESS : QCLOUD_ERR_FAILURE;
}
 ```

- 智能灯示例上行示例

```

/*定时修改属性状态，实现定时上报*/
static void cycle_report(void *pClient, Timer *reportTimer)
{
    int           i;
    DataTemplate *pTemplateData = IOT_Template_Get_DataTemplate(pClient);

    if (expired(reportTimer)) {
        for (i = 0; i < TOTAL_PROPERTY_COUNTS; i++) {
            pTemplateData->method.set_property_state(pClient, i, eCHANGED);
            countdown_ms(reportTimer, 5000);
        }
    }
}

/*刷新属性状态*/
static void refresh_local_property(void *pClient)
{
    // add your local property refresh logic, cycle report for example
    cycle_report(pClient, &sg_reportTimer);
}

/* 汇集待上报的属性列表，主逻辑会自动构建上行数据并上报 */
int deal_up_stream_user_logic(void *pClient, DeviceProperty *pReportDataList[], int *pCount)
{
    DataTemplate *pTemplateData = IOT_Template_Get_DataTemplate(pClient);

    // refresh local property
    refresh_local_property(pClient);

    /*find propery need report*/
    *pCount = pTemplateData->method.find_wait_report_property(pClient, pReportDataList);

    return (*pCount > 0) ? QCLOUD_RET_SUCCESS : QCLOUD_ERR_FAILURE;
}

```